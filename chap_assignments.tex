%Assignments

Assignments are a way for a user or a programmer to assign a value to a variable. 
The way we assign a value to a variable in C++ is different from how we might do it in math. 
In mathematics we are allowed to say that \Code{x = 3} or \Code{3 = x}, but in C++ the only acceptable way to assign the value of \Code{3} to \Code{x} is to type \Code{x = 3}. 

The \Code{=} in the expression \Code{x = 3} is known as an \Keyword{assignment operator}. 
This allows the program to set a variable's value depending on its type. 
Here are some examples of setting a value to different types of variables:

\begin{lstlisting}
		int x = 4;
\end{lstlisting}
\begin{lstlisting}
		char alpha = 'A';
\end{lstlisting}
\begin{lstlisting}
		string word = "Alpha";
\end{lstlisting}
\begin{lstlisting}
		float y = 3.14;
\end{lstlisting}

We are able to declare variables and assign a value to those variables immediately by using the assignment operator. 
When we assign literal values to variables of type char, the value must be surrounded by single quotes (for example, \Code{'A'}). 
When we assign values to variables of type \Code{string}, the literal value must be surrounded by double quotes (for example, \Code{"Alpha"}). 
We do not have to initialize the values of the variables, however. 
We can set them later in the code like this:

\begin{lstlisting}
		int myVal;
		//some code
		myVal = 0; 
\end{lstlisting}

In all of the lines of code in this section where a variable is set using the assignment operator, the ``thing that is being given a value'' is known as an \Keyword{lvalue}, and the expression on the right that is being stored in the variable is known as the \Keyword{rvalue}. 
Literals such as \Code{'A'} or \Code{3} can never be an lvalue. 
Aside from literals, the rvalue can consist of other variables, like this:

\begin{lstlisting}
		myVal = myVal2;
\end{lstlisting}

Even though \Code{myVal2} is a variable, we are only using the \textit{value stored in the variable}, not the variable itself. 
For example, if \Code{myVal2} had a value of \Code{6}, \Code{myVal} would then be assigned to the value \Code{6} with the above code. 

We can also store the results of an arithmetic expression in a variable like this: 

\begin{lstlisting}
  myVal = 5 + 6; //assigns myVal a value of 11
\end{lstlisting}

But we can't write
\begin{lstlisting}
  5 + 6 = myVal; // ERROR!
\end{lstlisting}

\noindent since \Code{5 + 6} doesn't refer to a place where we can store a value. 
We can also combine arithmetic expressions with variables as an rvalue like this:

\begin{lstlisting}
  myVal2 = 6;
  myVal = 4 + myVal2;
\end{lstlisting}

In this case, the variable \Code{myVal} would be assigned a value of \Code{10} because the variable \Code{myVal2} was initialized to a value of \Code{6}, and \Code{4 + 6} is \Code{10}.
The value of \Code{myVal2} remains unchanged. 
Make sure that the variable \Code{myVal}, the variable \Code{myVal2}, and the literal \Code{4} are of the same type. 
For example, the following code will result in an error:

\begin{lstlisting}
  int myValue = 4;
  int yourVal;
  string myString = "word";
		
  yourVal = myValue + myString; 
  // Adding string to an int is
  // probably not what you meant!
\begin{lstlisting}

When we try to combine different variable types, the compiler will get very mad at us. 
Some exceptions to this rule are if we try to combine \Code{float}s, \Code{int}s, and \Code{double}s.
These types have the ability to be combined (to a certain extent) because they are all numeric values.
Both \Code{double}s and \Code{float}s can hold values with a decimal point such as \Code{-3.14}, \Code{0.003}, or \Code{5.167289} whereas an \Code{int} can only hold round values such as \Code{2}, \Code{-18}, or \Code{100}. Refer to Chapter \ref{chap_datatypes} for more information on converting between data types.


