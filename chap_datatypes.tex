%Analogy

Suppose you need to carry two products across a farmyard: apples and water. 
The container you choose would depend on the product, and how much of the product you have to move. 
You might choose a small hand basket to carry a few apples, and a larger bushel basket to carry a large number of apples. 
Similarly, you could use a one-gallon bucket or a five-gallon bucket, depending on how much water you expected to move. 

In a similar way, we choose data types to describe the type of data we would like to store in a variable, and ``how much'' of that data we expect to store.

Every variable has a \Keyword{data type} which describes the range of possible values that may be stored in the variable. 
The C++ language defines a handful of basic types, some of which were discussed in Chapter \ref{chap_assignments}. 
These types, their sizes (which may vary depending on the operating system), and the range of possible values are:

\begin{table}[tb]
	\centering
		\begin{tabular}{| l | l | p{3in} |}
		\hline
			\Code{bool} & 1 byte & \Code{true} or \Code{false} \\ \hline
			\Code{char} & 1 byte & $-128$ to $127$ \\ \hline
			\Code{short int} (\Code{short}) & 2 bytes & $-32,768$ to $32,767$ \\ \hline
			\Code{int} & 4 bytes & $-2,147,483,648$ to $2,147,483,647$ \\ \hline
			\Code{long int} (\Code{long} & 4 bytes & $-2,147,483,648$ to $2,147,483,647$ \\ \hline
			\Code{float} & 4 bytes & See ``Floating-point Types'' below \\ \hline
			\Code{double} & 8 bytes & See ``Floating-point Types'' below \\ \hline
			\Code{long double} & 8 bytes & See ``Floating-point Types'' below \\ \hline
		\end{tabular}
\end{table}
	
\noindent Additionally, the C++11 standard provides for the following type:

\begin{table}[tb]
	\centering
		\begin{tabular}{| l | l | p{3in} |}
		\hline
			\textbf{Type} & \textbf{Size} & \textbf{Range of Values} \\ \hline
			\Code{long long int} (\Code{long long}) & 8 bytes & $-9,223,372,036,854,775,808$ to $9,223,372,036,854,775,807$ \\ \hline
		\end{tabular}
\end{table}

Several of the integer types have unsigned versions, which may only contain values greater than or equal to zero. 
The \Keyword{floating-point types} do not have unsigned versions, as the sign is part of the standard that defines how these variables are represented in memory. 

\begin{table}[tb]
	\centering
		\begin{tabular}{| l | l | p{3in} |}
		\hline
			\textbf{Type} & \textbf{Size} & \textbf{Range of Values} \\ \hline
			\Code{unsigned char} & 1 byte & $0$ to $255$ \\ \hline
			\Code{unsigned short} & 2 bytes & $0$ to $65,535$ \\ \hline
			\Code{unsigned int} & 4 bytes & $0$ to $4,294,967,295$ \\ \hline
			\Code{unsigned long} & 4 bytes & $0$ to $4,294,967,295$ \\ \hline
			\Code{unsigned long long}\footnote{This data type is found in the C++11 standard.} & 8 bytes & $0$ to $18,446,744,073,709,551,615$ \\ \hline
		\end{tabular}
\end{table}

\LevelD{Floating-point types}

Floating-point types are used to represent numbers that are not whole integers. 
For example:

\begin{lstlisting}
float f = 3.35;
\end{lstlisting}

Variables of type \Code{float} and of type \Code{double} store these numbers in similar components as scientific notation, so the above value could be represented as $335 \times 10^{-2}$. 
The first part, $335$, (sometimes called the \Keyword{coefficient} or \Keyword{significand}) is stored separately from the second part, $-2$, (called the \Keyword{exponent}). 
The types can represent different ranges of significand and exponents, as shown in the following table:

\begin{table}[tb]
	\centering
		\begin{tabular}{| l | l | p{3in} |}
		\hline
			\textbf{Type} & \textbf{Exponent Range} & \textbf{Significand Range} \\ \hline
			\Code{float} & $0$ to $255$ & $2^23$: $8,388,608$ possible values \\ \hline
			\Code{double} & $0$ to $2,048$ & $2^52$: $4,503,599,627,370,496$ possible values \\ \hline
			\Code{long double} & $0$ to $2,048$	& $2^52$: $4,503,599,627,370,496$ possible values \\ \hline
		\end{tabular}
\end{table}

In fact, we can use scientific notation in conjunction with floating-point variables. 
The previous code that assigned a value to \Code{f} can also be written as:

\begin{lstlisting}
float f = 335e-2; // Sets f to 3.35
\end{lstlisting}

Refer to Chapter \ref{chap_output} for a discussion on displaying \Code{float}s and \Code{double}s.

Both \Code{float} and \Code{double} include a few special values that represent non-numeric results, such as infinity, negative infinity, and \Code{NaN} (Not a Number).

\begin{lstlisting}
float g = 10.0 / 0.0; // g is set to infinity
float h = g * -1.0; // h is set to negative infinity
float i = g / h; // Since infinity divided by negative infinity is undefined,
// the result of the division is not a number, and i is set to NaN
\end{lstlisting}

\LevelD{Other types introduced by C++11}

C++11 provides the \Code{cstdint} library, which defines several additional types that may be convenient:

\begin{table}[tb]
	\centering
		\begin{tabular}{| l | p{3in} | l |}
		\hline
			\textbf{Type} & \textbf{Purpose} & \textbf{Unsigned version} \\ \hline
			\Code{intmax_t} & The integer of maximum size supported on the platform & \Code{uintmax_t} \\ \hline
			\Code{int8_t} & An integer of exactly 8 bits & \Code{uint8_t} \\ \hline
			\Code{int16_t} & An integer of exactly 16 bits & \Code{uint16_t} \\ \hline
			\Code{int32_t} & An integer of exactly 32 bits & \Code{uint32_t} \\ \hline
			\Code{int64_t} & An integer of exactly 64 bits & \Code{uint64_t} \\ \hline
		\end{tabular}
\end{table}

These types are provided in part because the basic types like \Code{int} and \Code{short} are not guaranteed to be of any particular size, which can cause problems when compiling the same code on different platforms.

\LevelD{Conversion Between Types}

It is sometimes necessary to convert a variable of one type to another, perhaps in order to pass the variable to a function that doesn't support the variable's original type. 
Here is an example of a variable of type \Code{int} being converted (automatically) to a \Code{double}:

\begin{lstlisting}
  int x = 2;
  double y;
  y = x; // Type conversion: the integer 2 is converted to the double 2.0
  cout << "y = " << y << endl; // This prints y = 2
\end{lstlisting}

This example demonstrates a \Keyword{widening conversion}, since any possible value of \Code{x} can be represented in \Code{y}. 
On the other hand, we can do the reverse conversion:

\begin{lstlisting}
  int x;
  double y = 2.0;
  x = y; // Type conversion: the double 2.0 is converted to the int 2
  cout << "x = " << x << endl; // This prints x = 2
\end{lstlisting}

This code compiles and runs, but the compiler produces the following warning:

\begin{lstlisting}
warning: converting to 'int' from 'double'
\end{lstlisting}

The compiler has a good reason for this warning: not all possible values that can be represented in a \Code{double} can be represented in an \Code{int}. 
We refer to this as a \Keyword{narrowing conversion}. 
If we change the code slightly, we can see where problems can occur:

\begin{lstlisting}
  int x;
  double y = 2.9;
  x = y; // Type conversion: the double 2.9 is converted to the int 2
  cout << "x = " << x << endl; // This prints x = 2
\end{lstlisting}

Because integers cannot represent the numbers after the decimal point, they are simply dropped. 
This might seem counterintuitive, as we might expect the values to be rounded up from \Code{2.9} to \Code{3}. 
Fortunately, C++11 provides a \Code{round()} function in the \Code{<cmath>} library that returns the integer closest to the passed parameter:

\begin{lstlisting}
  int x;
  double y = 2.9;
  x = round(y); // round(y) returns the double 3.0 (the closest integer to the passed parameter)
  // This double is then converted to the int 3
  cout << "x = " << x << endl; // This prints x = 2
\end{lstlisting}

\LevelD{Coercion \& Casting}

The examples in the previous section relied on the compiler to perform the conversions from \Code{int} to \Code{double} and \Code{double} to \Code{int}. 
This implicit, automatic conversion is often referred to as \Keyword{coercion}, and can be found in the following example:

\begin{lstlisting}
  int z = 3.3 + 4.8; // z is set to the integer 8 (coerced from the double 8.1)
\end{lstlisting}

The compiler still warns us that it is converting the \Code{double} to an \Code{int}. 
In this case, we know that we want an integer value, so we can tell the compiler to explicitly convert the \Code{double}s to \Code{int}s using explicit \Keyword{casts}, as follows:

\begin{lstlisting}
int z = (int)3.3 + (int)4.8; // z is set to 7
\end{lstlisting}

We enclose the ``target'' type in parentheses (in this case, \Code{int}) and place it before the value or expression we want to convert. 
Doing this removes the warning that the compiler produces when it coerces the \Code{double} to \Code{int}. 
The above still isn't quite what we want, though, since the individual \Code{double}s are converted to $3$ and $4$, respectively. 
(Remember that converting from a \Code{double} to an \Code{int} drops the part after the decimal point rather than rounding!) 
It would be better to convert the result of the addition, rather than the individual values, like this:

\begin{lstlisting}
int z = (int)(3.3 + 4.8); // z is set to 8
\end{lstlisting}

\LevelD{Automatic Types in C++11}

C++11 introduces the \Code{auto} data type, which leaves the determination of a variable's type up to the compiler. 
At compile time, the data type of the value that is assigned determines the data type that replaces the \Code{auto} type.

\begin{lstlisting}
auto myVar = 3; // myVar is an int
auto myVar2 = &myVar; // myVar2 is an int*
auto myVar3 = 't'; // myVar3 is a char
\end{lstlisting}

The \Code{decltype} operator is another new feature, which extracts types from objects and is used in a similar way as \Code{auto}:

\begin{lstlisting}
auto myVar = 3; // myVar is an int
decltype(myVar) myVar4; // myVar4 is an int
decltype(myVar < 1) myVar5; // myVar5 is a bool
\end{lstlisting}

In these examples, it is easy to determine the types assigned to the variable, but the power of \Code{auto} is in conjunction with complicated types like iterators of container objects as discussed more in Chapter \ref{chap_stl}. Here is an example:

\begin{lstlisting}
std::vector<int> v; // Create a vector of integers
v.push_back(2); // Add 2 to the vector
v.push_back(8); // Add 8 to the vector
auto myIterator = v.begin();
// The above is equivalent to:
// std::vector<int>::iterator myIterator = v.begin();
\end{lstlisting}

\LevelD{Review Questions}

\LevelD{Homework Questions}

\LevelD{Review Answers}

\LevelD{Homework Answers}

\LevelD{Further Reading}

\begin{itemize}
\item \url{http://www.cplusplus.com/reference/cstdint/}
\item \url{http://en.wikipedia.org/wiki/Floating_point}
\item \url{http://en.wikipedia.org/wiki/IEEE_floating_point}
\item \url{http://www.learncpp.com/cpp-tutorial/25-floating-point-numbers/}
\end{itemize}	

